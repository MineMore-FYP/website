<p><a (click)="goTo('yourfirstWF')">Introduction to your first SciFlow Workflow </a></p>
<p><a (click)="goTo('runningyourWF')">Running the Workflow</a></p>
<p><a (click)="goTo('modules')">Step 01 : Constructing your modules</a></p>
<p><a (click)="goTo('Parallelizable-functions')">Step 02 : Identify Parallelizable functions</a></p>
<p><a (click)="goTo('inputs')">Step 03 : Giving your inputs</a></p>
<p><a (click)="goTo('controlThread')">Step 04 : Writing your control thread</a></p>
<p><a (click)="goTo('Dynamic-decisions')">Step 05 : Dynamic decision making</a></p>
<p><a (click)="goTo('parsl-config')">Step 06 : Configuring Parsl</a></p>
<br>

<div id="yourfirstWF">
<h4><b>Introduction to your first SciFlow Workflow</b></h4>

<p>Let us explore the possibilities provided by SciFlow with a simple example.</p>

<p>Mrs. Branson, Central High School’s Mathematics teacher wants to create a portal where her students could inquire whether they performed well during a semester or not. Student performance is calculated based on 10 different assignments given throughout the semester and marks are given out of 50 for each.</p>

<p>Mrs. Branson has the following data with her;</p>

<ul>
  <li>Student Name. Eg : “John”</li>
  <li>List of student’s marks for the 10 assignments, out of 50. Eg : [23,45,26,47,28,38,46,43,32,44]</li>
  <li>The total assignment marks for the rest of the students, out of 1000.
  Eg : [927,734,358,212,938,603,912,592,657,556,740,625,495,864,346,623,824,543,951,591,833,340,690,544,
  797,818,847,791,727,652,856,651,686,964,765,732,662,674,714]</li>
</ul>

<p>The SciFlow framework could be easily used to construct a workflow in order to achieve Mrs. Branson’s vision.</p>

<img src="../../../assets/png/simpleWorkflow.png" alt="Smiley face" class="center" width="500px">

<ol>
  <li>The student would be greeted first, by printing “Hello John!”</li>
  <li>Thereafter, each of his marks would be multiplied by two, using parallel execution.</li>
  <li>Then the class average would be calculated.</li>
  <li>Based on a comparison between John’s total marks and the class average, the system would tell John whether he had an amazing/terrible semester.</li>
</ol>

<p>This example workflow emphasises several key features provided by SciFlow;</p>

<p><b>Dynamic execution</b></p>

<p>The control thread would make a decision on the path to take, going forward. In the example provided, the control thread would compare John’s mark with the class average and adjust the path accordingly.</p>

<p><b>Implicit Parallelism</b></p>

<p>Multiplying John’s marks is performed parallely. Each mark in the array is handled parallely using the Parsl library.</p>

<p><b>High Performance Computing</b></p>

<p>Mrs. Branson could easily configure the systems to run on her machine’s threads, cores or even a cluster, by simply loading a pre-written configuration file.</p>
</div>
<br>

<div id="runningyourWF">
<h4><b>Running the Workflow</b></h4>

<p>You can run this workflow by downloading the SciFlow framework from <a href="https://github.com/SciFlow-FYP/SciFlow">https://github.com/SciFlow-FYP/SciFlow</a>, using the terminal to navigate to the SciFlow folder and then running the command, go run controlThread.go</p>

<p>This would give you the following output;</p>

<img src="../../../assets/png/cmd.png" alt="Smiley face" class="center" width="700px">

<p>The output indicates that John had a better semester than his peers. The control thread made this decision and re-directed the path accordingly. </p>

<p>Next, let’s take a look at how to construct this simple workflow.</p>


</div>
<br>

<div id="modules">
  <h4><b>Step 01 : Constructing your modules</b></h4>

<p>Individual workflow modules go inside the “workflow” folder of the SciFlow framework. You can break the workflow into several components as you wish. Do so by adding a subfolder within the workflow folder.</p>

<p>Our workflow consists of three workflow components;</p>

<ul>
  <li>WFComponent1, which includes student greeting module.</li>
  <li>WFComponent2, which includes all calculation modules.</li>
  <li>WFComponent3, for conveying to the student whether he had an amazing or terrible semester, in comparison to his peers.</li>
</ul>

<p>Within these workflow components, python modules need to be written, for the required functionalities. Such modules are reusable, and therefore, can be repurposed for any workflow you write hereafter. Accordingly, our workflow comprises of the following python modules.</p>

<img src="../../../assets/png/structure.png" alt="Smiley face" class="center" width="400px">

<p>Make sure that your modules print a string at the very end! This is sent through a channel and is important to detect completion of the module.</p>

<div id="codeSnippet">
<pre><code>print("Module Completed : Calculate Class Average")</code></pre>
</div>
<p>In future, when you intend to construct a different workflow, write your modules here. You can even re-use the modules we have written in our projects at; </p>

<ul>
  <li><a href="https://github.com/SciFlow-FYP/parsl">Data Analytics Case Study</a></li>
  <li><a href="https://github.com/SciFlow-FYP/TravellingSalesmanProblem">Travelling Salesman Problem</a></li>
</ul>

</div>
<br>

<div id="Parallelizable-functions">

  <h4><b>Step 02 : Identify Parallelizable functions</b></h4>

<p>SciFlow uses the python parallel scripting library, Parsl, in order to provide controlled implicit parallelism. </p>

<p>Firstly, you should identify functions which could be performed in parallel. In our workflow, multiplyByTwo.py includes such a function. Mrs. Branson assigns marks out of 50. This needs to be converted to marks out of 100, in order to conform to school policy. To do so, she must multiply the list of John’s marks by two. Since each multiplication is independent of each other, this function could be performed in parallel.  </p>

<p>The parallelization process is two-fold;</p>

<ul>
  <li>Annotate functions that can be executed in parallel as Parsl apps.</li>
  <li>Specify dependencies between functions using standard Python code.</li>
</ul>

<p>In Parsl, an <b>app</b> is a piece of code that can be asynchronously executed on an execution resource. Parsl provides support for pure Python apps (python_app). The execution of an app yields futures. These futures can be passed to other apps as inputs, establishing a dependency. </p>

<p>Let’s parallelize the <b>multiplyByTwo(x)</b> function in <b>workflow/WFComponent2/multiplyByTwo.py</b>. This  is made a Parsl App using the <b>@python_app</b> decorator.</p>

<div id="codeSnippet">
<pre>
  <code>
@python_app
def multiplyByTwo (x):
    multiplyByTwo = x*2
    return multiplyByTwo
</code>
</pre>
</div>

<p>The most common way that Parsl apps are executed in parallel is via looping. A simple for loop could be used in order to multiply each element in the marks array in parallel.</p>

<div id="codeSnippet">
<pre>
  <code>
mulTwoArray = []
for i in studentMarks:
    mulTwoArray.append(multiplyByTwo(i).result())
  </code>
  </pre>
  </div>

<p>For further instructions on parallelization with Parsl, check out their user guide at <a href="https://parsl.readthedocs.io/en/stable/userguide/index.html">https://parsl.readthedocs.io/en/stable/userguide/index.html</a></p>

</div>
<br>

<div id="inputs">


<h4><b>Step 03 : Giving your inputs</b></h4>

<p>The python modules you wrote would require certain user inputs. You can include this in workflow/userScript.py</p>

<p>Our workflow’s modules require,</p>

<ul>
  <li>The student’s name</li>
  <li>List of student’s marks for the 10 assignments, out of 50.</li>
  <li>The total assignment marks for the rest of the students, out of 1000.</li>
</ul>

<p>These are included in the userScript as follows; </p>

<div id="codeSnippet">
<pre>
  <code>
'''############WFComponent1###############'''

studentName = "John."

'''############WFComponent2###############'''

studentMarks = [23,45,26,47,28,38,46,43,32,44]

classMarks  = [927,734,358,212,938,603,912,592,657,556,740,625,495,864,346,623,824,543,951,591,833,340,690,
544,797,818,847,791,727,652,856,651,686,964,765,732,662,674,714]

'''############WFComponent3###############'''

durationType = "Semester"
</code>
</pre>
</div>

<p>Additionally, you should recognize your workflow modules by assigning them numbers. Make sure to include the assigned number with a single hash (#) and the calling module path with double hash marks (##). </p>

<div id="codeSnippet">
<pre>
  <code>
#Workflow
#0
##WFComponent1/studentGreeting.py
#1
##WFComponent2/multiplyByTwo.py
#2
##WFComponent2/calculateAvg.py
#3
##WFComponent3/amazing.py
#4
##WFComponent3/terrible.py
</code>
</pre>
</div>

</div>
<br>

<div id="controlThread">

<h4><b>Step 04 : Writing your control thread</b></h4>

<p>The workflow is constructed in the main function of the <b>“controlThread.go”</b> file. The commands array is captured from the “userScript.py” file, where we assign a number to each workflow module. The control thread executes the module based on this numbering.</p>

<div id="codeSnippet">
<pre>
  <code>
//start module execution from here onwards
inChannelModule1 := make(chan string, 1)
outChannelModule1 := make(chan string, 1)
go pythonCall("workflow/"+commandsArray[0], inChannelModule1,"1")
go messagePassing(inChannelModule1, outChannelModule1)
fmt.Println(<-outChannelModule1)

outChannelModule2 := make(chan string, 1)
go pythonCall("workflow/"+commandsArray[1], outChannelModule2, "1")
go messagePassing(outChannelModule1, outChannelModule2)
fmt.Println(<- outChannelModule2)
</code>
</pre>
</div>

<p>The above code snippet corresponds to the first and second workflow modules (studentGreeting and multiplyByTwo). Channels are used to create dependency between modules. If you examine the above coe, you could observe that the out channel of the first module is fed as the in channel to the second module.</p>
<p>Make sure to add in a similar code segment for each new workflow step. Replace <b>n</b> with the appropriate number, in an incremental fashion and <b>i</b> with the assigned index (from the userScript) of the module you wish to execute.</p>

  <div id="codeSnippet">
  <pre>
    <code>
  outChannelModulen := make(chan string, 1)
  go pythonCall("workflow/"+commandsArray[i], outChannelModulen, "1")
  go messagePassing(outChannelModule(n-1), outChannelModulen)
  fmt.Println(<- outChannelModulen)
  </code>
  </pre>
  </div>

<p>Check out different ways to construct workflows in the section <a href="#">Special Workflow Constructs!</a></p>

</div>
<br>

<div id="Dynamic-decisions">

<h4><b>Step 05 : Dynamic decision making</b></h4>

<p>Allow the framework to make path decisions by defining a control logic in “controlThread.go”. In this scenario, the decision that needs to be made is whether the student had a good semester or a bad one. The decision is to be made by comparing the individual student’s mark (out of 1000), with the class average. </p>

<img src="../../../assets/png/simpleWorkflow copy.png" alt="Smiley face" class="center" width="400px">

<!--
<div id="codeSnippet">
<pre>
  <code>
//Dynamic decision making based on student total and class average
outChannelModule4 := make(chan string, 1)

if studentTot >= int(classAvg) {
    //send to 'amazing' module
    go pythonCall("workflow/"+commandsArray[3], outChannelModule4, "1")
    go messagePassing(outChannelModule3, outChannelModule4)
    fmt.Println(<- outChannelModule4)
 } else {
    //send to 'terrible' module
    go pythonCall("workflow/"+commandsArray[4], outChannelModule4, "1")
    go messagePassing(outChannelModule3, outChannelModule4)
    fmt.Println(<- outChannelModule4)
 }
</code>
</pre>
</div>-->

<p>Get creative and write any suitable logic with a simple if condition!</p>

</div>
<br>

<div id="parsl-config">

<h4><b>Step 06 : Configuring Parsl </b></h4>

<p>Parsl separates code and execution. To do so, it relies on a configuration model to describe the pool of resources to be used for execution (e.g., clusters, clouds, threads, cores).</p>
<p>The configuration provided to Parsl tells Parsl what resources to use to run the Parsl program and apps, and how to use them. Within the SciFlow framework, we have included the following configurations;</p>

<ul>
  <li>Threads on your local machine (local_threads)</li>
  <li>Cores on your local machine (local_htex)</li>
  <li>On an Ad Hoc Cluster (remote_htex)</li>
</ul>


<p>You can simply load these pre-written configurations with the following command in the <b>workflow/parslConfig.py</b> file.</p>

<div id="codeSnippet">
<pre>
  <code>
parsl.load(config_name)
</code>
</pre>
</div>


<p>The configuration files (in <b>workflow/configs/</b>) need to be slightly amended as per the configurations of your machine/cluster.</p>

<table class="table table-hover table-bordered">
  <thead>
      <tr>
        <th></th>
        <th>Provider, channel and executor</th>
        <th>Parameters to be Changed</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><b>Local Threads</b></td>
        <td>
          <p>from parsl.executors.threads import ThreadPoolExecutor</p>
        </td>
        <td>
          <p>max_threads – Number of threads.</p>
          <p>Default is 2.</p>
        </td>
      </tr>
      <tr>
        <td><b>Local Cores</b></td>
        <td>
          <p>from parsl.providers import LocalProvider</p>
          <p>from parsl.channels import LocalChannel</p>
          <p>from parsl.executors import HighThroughputExecutor</p>
        </td>
        <td>
          <p>cores_per_worker – cores to be assigned to each worker. </p>
          <p>Oversubscription is possible by setting cores_per_worker < 1.0. Default is 1.</p>

        </td>
      </tr>
      <tr>
        <td><b>Ad-Hoc Cluster</b></td>
        <td>
          <p>from parsl.providers import AdHocProvider</p>
          <p>from parsl.channels import SSHChannel</p>
          <p>from parsl.executors import HighThroughputExecutor</p>
          <p>from parsl.providers import LocalProvider</p>
          <p>from parsl.channels import LocalChannel</p>

        </td>
        <td>
          <p>'username': ‘YOUR USERNAME’</p>
          <p>'script_dir': 'YOUR SCRIPT DIRECTORY'</p>
          <p>'remote_hostnames': ['REMOTE HOST URL 1','REMOTE HOST URL 2', ...]</p>
        </td>
      </tr>
    </tbody>


</table>

<p>Parsl provides numerous other execution environments as well, such as, Amazon Web Services, Google Cloud, Slurm based cluster or supercomputer, Torque/PBS based cluster or supercomputer, Kubernetes cluster etc. If you wish to configure SciFlow for these environments, you could easily do so by writing the configuration within the workflow/configs/ folder and thereafter, loading it in the workflow/parslConfig.py file.</p>
<p>Take a look at <a href="https://www.google.com/url?q=https://parsl.readthedocs.io/en/stable/userguide/configuring.html&sa=D&ust=1577686169444000&usg=AFQjCNH6U2YMs-WXvnS4vGo2wLVJaxgbvg">Parsl’s documentation</a> for further information on configuration!</p>


</div>
